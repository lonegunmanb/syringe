package rover

import (
	"bufio"
	"fmt"
	"github.com/lonegunmanb/syringe/ast"
	"github.com/lonegunmanb/syringe/codegen"
	"github.com/lonegunmanb/syringe/ioc"
	"github.com/lonegunmanb/syringe/util"
	"io"
	"os"
	"path/filepath"
	"strings"
)

var codeWriterContainer = ioc.NewContainer()

func GenerateCode(startingPath string, osEnv ast.GoPathEnv, writerFactory func(filePath string) (io.Writer, error)) error {
	if !filepath.IsAbs(startingPath) {
		absPath, err := filepath.Abs(startingPath)
		if err != nil {
			return err
		}
		startingPath = absPath
	}
	pkgPath, err := ast.GetPkgPath(osEnv, startingPath)
	pkgName := getPkgName(pkgPath)

	if err != nil {
		return err
	}
	rover := newCodeRover(startingPath)
	typeInfos, err := rover.getStructTypes()
	if err != nil {
		return err
	}
	for _, typeInfo := range typeInfos {
		fileName := fmt.Sprintf("%s.go", strings.ToLower(typeInfo.GetName()))
		createFileName := fmt.Sprintf("gen_%s", fileName)
		filePath := osEnv.ConcatFileNameWithPath(typeInfo.GetPhysicalPath(), createFileName)
		count := 1
		for {
			needRename, err := nonGeneratedFileExisted(filePath)
			if err != nil {
				return err
			}
			if !needRename {
				break
			}
			createFileName = fmt.Sprintf("gen_%s_%d.go", strings.ToLower(typeInfo.GetName()), count)
			filePath = osEnv.ConcatFileNameWithPath(typeInfo.GetPhysicalPath(), createFileName)
			count++
		}
		writer, err := writerFactory(filePath)
		if err != nil {
			return err
		}
		err = writeHead(writer)
		if err != nil {
			return err
		}
		productCodegen := codegen.NewProductCodegen(typeInfo, writer)
		err = productCodegen.GenerateCode()
		if err != nil {
			return err
		}
	}
	registerFileName := fmt.Sprintf("%s/gen_register_ioc.go", startingPath)
	writer, err := writerFactory(registerFileName)
	if err != nil {
		return err
	}
	err = writeHead(writer)
	if err != nil {
		return err
	}
	registerCodegen := codegen.NewRegisterCodegen(writer, typeInfos, pkgName, pkgPath)
	err = registerCodegen.GenerateCode()
	if err != nil {
		return err
	}
	return nil
}

func CleanGeneratedCodeFiles(startingPath string, osEnv ast.GoPathEnv) error {
	r := newCodeRover(startingPath)
	fileRetrieverKey := (*util.FileRetriever)(nil)
	if !codeWriterContainer.Has(fileRetrieverKey) {
		codeWriterContainer.RegisterFactory(fileRetrieverKey, func(ioc ioc.Container) interface{} {
			return util.NewFileRetriever()
		})
	}
	fileRetriever := codeWriterContainer.ResolveByType(fileRetrieverKey).(util.FileRetriever)
	files, err := fileRetriever.GetFiles(r.roverStartingPath, isGoSrcFile)
	if err != nil {
		return err
	}
	for _, fileInfo := range files {
		filePath := osEnv.ConcatFileNameWithPath(fileInfo.Path(), fileInfo.Name())
		isGeneratedFile, err := isGeneratedFile(filePath)
		if err != nil {
			return err
		}
		if isGeneratedFile {
			err := os.Remove(filePath)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func isGeneratedFile(filePath string) (bool, error) {
	fi, err := os.Open(filePath)
	if err != nil {
		return false, err
	}
	defer func() {
		_ = fi.Close()
	}()

	br := bufio.NewReader(fi)
	content, _, _ := br.ReadLine()
	firstLine := string(content)
	return firstLine == commentHead, nil
}

const commentHead = "// Code generated by syringe. DO NOT EDIT."

var firstLine = fmt.Sprintf("%s\r\n", commentHead)

func writeHead(writer io.Writer) error {
	_, err := writer.Write([]byte(firstLine))
	return err
}

func getPkgName(goPath string) string {
	s := strings.Split(goPath, "/")
	return s[len(s)-1]
}

func nonGeneratedFileExisted(filePath string) (bool, error) {
	_, err := os.Stat(filePath)
	if !os.IsNotExist(err) {
		isGenerated, err := isGeneratedFile(filePath)
		return !isGenerated, err
	}
	return false, nil
}

func isGoSrcFile(info os.FileInfo) bool {
	return strings.HasSuffix(info.Name(), ".go")
}
